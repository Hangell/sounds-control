class t{constructor(){this.sources={},this.buffers={},this.isPlaying={},this.isLooping={},this.startTime={},this.pausedTime={},this.currentlyPlaying=null,this.playbackRates={},this.context=new(window.AudioContext||window.webkitAudioContext),this.gainNode=this.context.createGain(),this.gainNode.connect(this.context.destination),this.effectGainNode=this.context.createGain(),this.effectGainNode.connect(this.context.destination)}async loadSound(t,e){if(!this.buffers[e]){const s=await fetch(t),i=await s.arrayBuffer(),a=await this.context.decodeAudioData(i);this.buffers[e]=a}}isSoundLoaded(t){return!!this.buffers[t]}async play(t,e=0){if(!this.isSoundLoaded(t))throw new Error(`Sound ${t} not loaded`);this.stop(t);const s=this.context.createBufferSource();s.buffer=this.buffers[t],s.connect(this.gainNode),s.loop=this.isLooping[t]||!1,s.playbackRate.value=this.playbackRates[t]||1,s.start(0,e),this.sources[t]=s,this.isPlaying[t]=!0,this.startTime[t]=this.context.currentTime-e,this.currentlyPlaying=t,s.onended=()=>{this.isPlaying[t]=!1}}async playEffect(t){if(!this.isSoundLoaded(t))throw new Error(`Sound ${t} not loaded`);const e=this.context.createBufferSource();e.buffer=this.buffers[t],e.connect(this.effectGainNode),e.playbackRate.value=this.playbackRates[t]||1,e.start(0)}stop(t){this.sources[t]&&(this.pausedTime[t]=this.context.currentTime-this.startTime[t],this.sources[t].stop(0),this.sources[t].disconnect(),delete this.sources[t],this.isPlaying[t]=!1,this.currentlyPlaying===t&&(this.currentlyPlaying=null))}loop(t,e=0){this.isLooping[t]=!0,this.play(t,e)}setVolume(t){t<0?t=0:t>1&&(t=1),this.gainNode.gain.setValueAtTime(t,this.context.currentTime)}setEffectVolume(t){t<0?t=0:t>1&&(t=1),this.effectGainNode.gain.setValueAtTime(t,this.context.currentTime)}setPlaybackRate(t,e){this.sources[t]&&(this.sources[t].playbackRate.value=e),this.playbackRates[t]=e}setGlobalPlaybackRate(t){Object.keys(this.sources).forEach((e=>{this.setPlaybackRate(e,t)}))}faster(t,e=1.5){this.setPlaybackRate(t,e)}slow(t,e=.75){this.setPlaybackRate(t,e)}fasterEffect(t,e=1.5){this.setPlaybackRate(t,e)}slowEffect(t,e=.75){this.setPlaybackRate(t,e)}pauseAll(){Object.keys(this.sources).forEach((t=>{this.sources[t]&&(this.pausedTime[t]=this.context.currentTime-this.startTime[t],this.sources[t].stop(0),this.isPlaying[t]=!1)}))}resumeAll(){this.currentlyPlaying&&void 0!==this.pausedTime[this.currentlyPlaying]&&this.play(this.currentlyPlaying,this.pausedTime[this.currentlyPlaying])}}export{t as SoundsControl};
//# sourceMappingURL=index.esm.js.map
